// ============================================
// Prisma & Datasource
// ============================================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Enums
// ============================================
enum ReactionType {
  LIKE
  LOVE
  HAHA
  WOW
  SAD
}

enum ChatroomRole {
  OWNER
  ADMIN
  MODERATOR
  MEMBER
}

// Notifications
enum NotificationType {
  LOGIN               // New login on the account
  COMMENT_ON_POST     // Someone commented on user's post
  REPLY_ON_COMMENT    // Someone replied to user's comment
  REACTION_ON_POST    // Someone reacted to user's post
  NEW_FOLLOWER        // Someone followed the user
  POST_DELETED        // User deleted their post
}

// ============================================
// User & Auth
// ============================================
model User {
  id           String          @id @default(uuid())
  firstname    String          @db.VarChar(30)
  lastname     String?         @db.VarChar(30)
  bio          String?         @db.VarChar(160)   // Short bio for profile
  avatarUrl    String?
  email        String          @unique
  lastSeenAt   DateTime?                      // Online presence & sorting recently active users
  verified    Boolean         @default(false)   // Email verified
  isPrivate  Boolean         @default(false)   // Account privacy setting  


  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  // Relations
  credential   Credential?    @relation("UserCredential")
  posts        Post[]         @relation("UserPosts")
  comments     Comment[]      @relation("UserComments")
  reactions    Reaction[]     @relation("UserReactions")
  messages     Message[]     @relation("UserMessages")
  memberships  ChatroomUser[]                          // Explicit many-to-many with metadata
  chatroomsCreated Chatroom[] @relation("UserChatroomsCreated")

  followers    Follower[]      @relation("UserFollowers")
  following    Follower[]      @relation("UserFollowing")

  // Notifications
  notificationsReceived Notification[] @relation("UserNotificationsReceived")
  notificationsActed    Notification[] @relation("UserNotificationsActed")

  @@index([email, firstname])
}

model Follower {
  id           String   @id @default(uuid())
  followerId   String
  followingId  String

  createdAt    DateTime @default(now())

  // Relations
  follower     User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following    User     @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId]) // prevent duplicates
  @@index([followingId, followerId])  // query optimizations
}

model Credential {
  id               String   @id @default(uuid())
  passwordHash     String?                           // Hashed password (nullable if SSO)
  twoFactorEnabled Boolean  @default(false)
  twoFactorSecret  String?
  refreshToken     String?                           // For JWT refresh flows

  verificationToken String?                        // Email verification token
  verificationTokenExpiry DateTime?

  resetToken      String?                        // Password reset token
  resetTokenExpiry DateTime?

  userId           String   @unique
  user             User     @relation("UserCredential", fields: [userId], references: [id], onDelete: Cascade)

  googleId         String?  @unique
  facebookId       String?  @unique
  githubId         String?  @unique

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

// ============================================
// Social Feed
// ============================================
model Post {
  id          String       @id @default(uuid())
  content     String

  createdAt   DateTime     @default(now()) 
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?    

  createdById String
  createdBy   User         @relation("UserPosts", fields: [createdById], references: [id], onDelete: Cascade)
  images      PostImage[]

  comments    Comment[]    @relation("PostComments")
  reactions   Reaction[]   @relation("PostReactions")

  // Notifications referencing this post
  notifications Notification[]

  @@index([createdById, deletedAt])
}

model PostImage {
  id     String @id @default(cuid())
  url    String
  post   Post   @relation(fields: [postId], references: [id])
  postId String
}

model Comment {
  id           String      @id @default(uuid())
  content      String

  postId       String
  post         Post        @relation("PostComments", fields: [postId], references: [id], onDelete: Cascade)

  createdById  String
  createdBy    User        @relation("UserComments", fields: [createdById], references: [id], onDelete: Cascade)

  parentId     String?
  parent       Comment?    @relation("ReplyComments", fields: [parentId], references: [id], onDelete: Cascade)
  replies      Comment[]   @relation("ReplyComments")

  // Notifications referencing this comment
  notifications Notification[]

  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  deletedAt    DateTime?  

  @@index([postId])
  @@index([createdById])
  @@index([parentId, deletedAt, createdAt])
}

model Reaction {
  id           String        @id @default(uuid())
  type         ReactionType

  postId       String
  post         Post          @relation("PostReactions", fields: [postId], references: [id], onDelete: Cascade)

  createdById  String
  createdBy    User          @relation("UserReactions", fields: [createdById], references: [id], onDelete: Cascade)

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@unique([postId, createdById])      // one reaction per user per post
  @@index([postId, type, createdAt])              // quick counts by type

  // Notifications referencing this reaction
  notifications Notification[]
}

// ============================================
// Notifications
// ============================================
model Notification {
  id            String            @id @default(uuid())
  type          NotificationType

  // The user who receives this notification
  recipientId   String
  recipient     User              @relation("UserNotificationsReceived", fields: [recipientId], references: [id], onDelete: Cascade)

  // Optional second user involved in the event (actor). For POST_DELETED, this may equal recipient or be null
  actorId       String?
  actor         User?             @relation("UserNotificationsActed", fields: [actorId], references: [id], onDelete: SetNull)

  // Optional resource references for context
  postId        String?
  post          Post?             @relation(fields: [postId], references: [id], onDelete: SetNull)

  commentId     String?
  comment       Comment?          @relation(fields: [commentId], references: [id], onDelete: SetNull)

  reactionId    String?
  reaction      Reaction?         @relation(fields: [reactionId], references: [id], onDelete: SetNull)

  // Extra flexible payload for UI (e.g., excerpt, preview)
  metadata      Json?

  isRead        Boolean           @default(false)
  readAt        DateTime?
  createdAt     DateTime          @default(now())

  @@index([recipientId, isRead, createdAt])
  @@index([actorId, createdAt])
  @@index([postId])
  @@index([commentId])
}

// ============================================
// Chat: Rooms, Memberships, Messages
// ============================================
model Chatroom {
  id           String         @id @default(uuid())
  name         String?
  isGroup      Boolean        @default(false)          // Distinguish DMs vs group chats
  avatarUrl    String?
  createdById  String
  createdBy    User           @relation("UserChatroomsCreated", fields: [createdById], references: [id], onDelete: Cascade)

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  deletedAt    DateTime?                        // Soft delete support

  memberships  ChatroomUser[]
  messages     Message[]   @relation("ChatroomMessages")

  @@index([createdById])
  @@index([createdAt])
}

model ChatroomUser {
  id           String       @id @default(uuid())
  userId       String
  chatroomId   String

  role         ChatroomRole @default(MEMBER)          // Roles/permissions per room
  joinedAt     DateTime     @default(now())
  lastReadAt   DateTime?                              // Read receipts / unread counts
  isMuted      Boolean      @default(false)           // Mute notifications per room

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatroom     Chatroom     @relation(fields: [chatroomId], references: [id], onDelete: Cascade)

  @@unique([userId, chatroomId])                      // Prevent duplicate membership
  @@index([chatroomId, userId])                       // Common queries per room
}

model Message {
  id          String     @id @default(uuid())
  content     String?                                   // Allow image-only messages
  imageUrl    String?

  userId      String     
  chatroomId  String     

  isEdited    Boolean    @default(false)
  createdAt   DateTime   @default(now()) 
  updatedAt   DateTime   @updatedAt
  deletedAt   DateTime?                             // Unsend / soft delete

  user        User       @relation("UserMessages", fields: [userId], references: [id], onDelete: Cascade)
  chatroom    Chatroom   @relation("ChatroomMessages", fields: [chatroomId], references: [id], onDelete: Cascade)

  @@index([chatroomId, createdAt, userId, deletedAt])                        // Pagination by time per room
}
